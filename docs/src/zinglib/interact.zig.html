<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>interact.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Functions for doing Network Interactions.</span></span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">const</span> ascii = std.ascii;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> log = std.log;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> meta = std.meta;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> net = std.net;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> os = std.os;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> process = std.process;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> time = std.time;</span>
<span class="line" id="L14"></span>
<span class="line" id="L15"><span class="tok-kw">const</span> lib = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zinglib.zig&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">const</span> conn = lib.connect;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> consts = lib.constants;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> recv = lib.recv;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> utils = lib.utils;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> Addresses = lib.Addresses;</span>
<span class="line" id="L21"><span class="tok-kw">const</span> Datagrams = lib.Datagrams;</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-kw">const</span> BUF_SIZE = <span class="tok-number">4096</span>;</span>
<span class="line" id="L24"></span>
<span class="line" id="L25"><span class="tok-comment">/// A Thread Safe, Array List based Buffer for Interactions.</span></span>
<span class="line" id="L26"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InteractBuffer = <span class="tok-kw">struct</span>{</span>
<span class="line" id="L27">    <span class="tok-comment">/// The ArrayList containing all Datagrams.</span></span>
<span class="line" id="L28">    _list: std.ArrayList(Datagrams.Full),</span>
<span class="line" id="L29">    <span class="tok-comment">/// A Mutex Lock for this Interaction Buffer.</span></span>
<span class="line" id="L30">    _mutex: std.Thread.Mutex = std.Thread.Mutex{},</span>
<span class="line" id="L31"></span>
<span class="line" id="L32">    <span class="tok-comment">/// Initialize a new Interaction Buffer with the provided Allocator (`alloc`).</span></span>
<span class="line" id="L33">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(alloc: mem.Allocator) <span class="tok-builtin">@This</span>(){</span>
<span class="line" id="L34">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L35">            ._list = std.ArrayList(Datagrams.Full).init(alloc),</span>
<span class="line" id="L36">        };</span>
<span class="line" id="L37">    }</span>
<span class="line" id="L38"></span>
<span class="line" id="L39">    <span class="tok-comment">/// Push a Datagram (`datagram`) to this Interaction Buffer.</span></span>
<span class="line" id="L40">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">push</span>(self: *<span class="tok-builtin">@This</span>(), datagram: Datagrams.Full) !<span class="tok-type">void</span> {</span>
<span class="line" id="L41">        self.*._mutex.lock();</span>
<span class="line" id="L42">        <span class="tok-kw">defer</span> self.*._mutex.unlock();</span>
<span class="line" id="L43">        <span class="tok-kw">try</span> self.*._list.insert(<span class="tok-number">0</span>, datagram);</span>
<span class="line" id="L44">    }</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">    <span class="tok-comment">/// Pop and return a Datagram from this Interaction Buffer or null if the ArrayList is empty.</span></span>
<span class="line" id="L47">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<span class="tok-builtin">@This</span>()) ?Datagrams.Full {</span>
<span class="line" id="L48">        <span class="tok-kw">if</span> (self._list.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L49">        self.*._mutex.lock();</span>
<span class="line" id="L50">        <span class="tok-kw">defer</span> self.*._mutex.unlock();</span>
<span class="line" id="L51">        <span class="tok-kw">return</span> self.*._list.pop();</span>
<span class="line" id="L52">    }</span>
<span class="line" id="L53">};</span>
<span class="line" id="L54"></span>
<span class="line" id="L55"><span class="tok-comment">/// A Thread Safe Writer for Interactions.</span></span>
<span class="line" id="L56"><span class="tok-comment">/// This wraps a provided Writer for thread safety.</span></span>
<span class="line" id="L57"><span class="tok-comment">///</span></span>
<span class="line" id="L58"><span class="tok-comment">/// The provided Writer Type (`WriterT`) must have the following functions:</span></span>
<span class="line" id="L59"><span class="tok-comment">/// - `write()`</span></span>
<span class="line" id="L60"><span class="tok-comment">/// - `writeAll()`</span></span>
<span class="line" id="L61"><span class="tok-comment">/// - `print()`</span></span>
<span class="line" id="L62"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">InteractWriter</span>(<span class="tok-kw">comptime</span> WriterT: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L63">    <span class="tok-kw">const</span> required_fns = &amp;.{ <span class="tok-str">&quot;write&quot;</span>, <span class="tok-str">&quot;writeAll&quot;</span>, <span class="tok-str">&quot;print&quot;</span> };</span>
<span class="line" id="L64">    <span class="tok-kw">for</span> (required_fns) |req_fn| {</span>
<span class="line" id="L65">        <span class="tok-kw">if</span> (!meta.hasFn(WriterT, req_fn)) {</span>
<span class="line" id="L66">            <span class="tok-builtin">@compileError</span>(fmt.comptimePrint(<span class="tok-str">&quot;The provided Writer Type '{s}' does not implement the required function '{s}()'.&quot;</span>, .{</span>
<span class="line" id="L67">                <span class="tok-builtin">@typeName</span>(WriterT),</span>
<span class="line" id="L68">                req_fn,</span>
<span class="line" id="L69">            }));</span>
<span class="line" id="L70">        }</span>
<span class="line" id="L71">    }</span>
<span class="line" id="L72"></span>
<span class="line" id="L73">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span>{</span>
<span class="line" id="L74">        <span class="tok-comment">/// The underlying Writer.</span></span>
<span class="line" id="L75">        writer: WriterT,</span>
<span class="line" id="L76">        <span class="tok-comment">/// The Read/Write Lock.</span></span>
<span class="line" id="L77">        rw_lock: std.Thread.RwLock = std.Thread.RwLock{},</span>
<span class="line" id="L78"></span>
<span class="line" id="L79">        <span class="tok-comment">/// Initialize a new Interaction Writer.</span></span>
<span class="line" id="L80">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(writer: WriterT) <span class="tok-builtin">@This</span>(){</span>
<span class="line" id="L81">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L82">                .writer = writer,</span>
<span class="line" id="L83">            };</span>
<span class="line" id="L84">        }</span>
<span class="line" id="L85"></span>
<span class="line" id="L86">        <span class="tok-comment">/// Write</span></span>
<span class="line" id="L87">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<span class="tok-builtin">@This</span>(), bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L88">            self.*.rw_lock.lock();</span>
<span class="line" id="L89">            <span class="tok-kw">defer</span> self.*.rw_lock.unlock();</span>
<span class="line" id="L90">            <span class="tok-kw">return</span> self.*.writer.write(bytes);</span>
<span class="line" id="L91">        } </span>
<span class="line" id="L92">        <span class="tok-comment">/// Write All</span></span>
<span class="line" id="L93">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: *<span class="tok-builtin">@This</span>(), bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L94">            self.*.rw_lock.lock();</span>
<span class="line" id="L95">            <span class="tok-kw">defer</span> self.*.rw_lock.unlock();</span>
<span class="line" id="L96">            <span class="tok-kw">return</span> self.*.writer.writeAll(bytes);</span>
<span class="line" id="L97">        } </span>
<span class="line" id="L98">        <span class="tok-comment">/// Print </span></span>
<span class="line" id="L99">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L100">            self.*.rw_lock.lock();</span>
<span class="line" id="L101">            <span class="tok-kw">defer</span> self.*.rw_lock.unlock();</span>
<span class="line" id="L102">            <span class="tok-kw">return</span> self.*.writer.print(format, args);</span>
<span class="line" id="L103">        } </span>
<span class="line" id="L104">    };</span>
<span class="line" id="L105">}</span>
<span class="line" id="L106"></span>
<span class="line" id="L107"><span class="tok-comment">/// Interaction Config.</span></span>
<span class="line" id="L108"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InteractConfig = <span class="tok-kw">struct</span>{</span>
<span class="line" id="L109">    <span class="tok-comment">/// Max number of Datagrams to be processed for this Interaction.</span></span>
<span class="line" id="L110">    <span class="tok-comment">/// Setting this to 0 will allow for infinite loops</span></span>
<span class="line" id="L111">    recv_dgs_max: <span class="tok-type">u32</span> = <span class="tok-number">10</span>,</span>
<span class="line" id="L112">    <span class="tok-comment">/// Batch Size for processing Datagrams.</span></span>
<span class="line" id="L113">    <span class="tok-comment">/// This is the number of Datagrams that will be sent to a Reaction Function.</span></span>
<span class="line" id="L114">    batch_size: <span class="tok-type">u16</span> = <span class="tok-number">1</span>,</span>
<span class="line" id="L115">    <span class="tok-comment">/// Run Reaction Functions in their own Thread.</span></span>
<span class="line" id="L116">    multithreaded: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L117">    <span class="tok-comment">/// Start Function Delay.</span></span>
<span class="line" id="L118">    <span class="tok-comment">/// The time (in ns) from the start of the Receiving Datagrams to when the Start Function is called.</span></span>
<span class="line" id="L119">    <span class="tok-comment">/// Note, this only works if `multithreaded` is enabled.</span></span>
<span class="line" id="L120">    start_fn_delay: <span class="tok-type">u32</span> = <span class="tok-number">1</span> * time.ns_per_s,</span>
<span class="line" id="L121">};</span>
<span class="line" id="L122"></span>
<span class="line" id="L123"><span class="tok-comment">/// Interaction Functions.</span></span>
<span class="line" id="L124"><span class="tok-comment">/// **Comptime Only!**</span></span>
<span class="line" id="L125"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InteractFunctions = <span class="tok-kw">struct</span>{</span>
<span class="line" id="L126">    <span class="tok-comment">/// A Function to be called at the Start of an Interaction.</span></span>
<span class="line" id="L127">    <span class="tok-comment">///</span></span>
<span class="line" id="L128">    <span class="tok-comment">/// Parameters:</span></span>
<span class="line" id="L129">    <span class="tok-comment">/// 1. Allocator</span></span>
<span class="line" id="L130">    <span class="tok-comment">/// 2. Context</span></span>
<span class="line" id="L131">    start_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(mem.Allocator, <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L132">    </span>
<span class="line" id="L133">    <span class="tok-comment">/// A Function to be called in Reaction to each Datagram received during an Interaction.</span></span>
<span class="line" id="L134">    <span class="tok-comment">///</span></span>
<span class="line" id="L135">    <span class="tok-comment">/// Parameters:</span></span>
<span class="line" id="L136">    <span class="tok-comment">/// 1. Allocator</span></span>
<span class="line" id="L137">    <span class="tok-comment">/// 2. Context - Must be a Nullable Pointer to a Type (`*T`).</span></span>
<span class="line" id="L138">    <span class="tok-comment">/// 3. Received Datagram</span></span>
<span class="line" id="L139">    react_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(mem.Allocator, <span class="tok-kw">anytype</span>, Datagrams.Full) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L140"></span>
<span class="line" id="L141">    <span class="tok-comment">/// A Function to be called at the End of an Interaction.</span></span>
<span class="line" id="L142">    <span class="tok-comment">///</span></span>
<span class="line" id="L143">    <span class="tok-comment">/// Parameters:</span></span>
<span class="line" id="L144">    <span class="tok-comment">/// 1. Allocator</span></span>
<span class="line" id="L145">    <span class="tok-comment">/// 2. Context</span></span>
<span class="line" id="L146">    end_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(mem.Allocator, <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L147">};</span>
<span class="line" id="L148"></span>
<span class="line" id="L149"><span class="tok-comment">/// Interact with a Network using the provided Allocator (`alloc`), Function Context (`fn_ctx`), and Interaction Config (`config`).</span></span>
<span class="line" id="L150"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">interact</span>(</span>
<span class="line" id="L151">    alloc: mem.Allocator, </span>
<span class="line" id="L152">    fn_ctx: <span class="tok-kw">anytype</span>, </span>
<span class="line" id="L153">    sock_config: conn.IFSocket.IFSocketInitConfig, </span>
<span class="line" id="L154">    ia_config: InteractConfig, </span>
<span class="line" id="L155">    <span class="tok-kw">comptime</span> ia_fns: InteractFunctions</span>
<span class="line" id="L156">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L157">    <span class="tok-comment">// Setup Sockets</span>
</span>
<span class="line" id="L158">    <span class="tok-kw">const</span> recv_sock = <span class="tok-kw">try</span> conn.IFSocket.init(sock_config);</span>
<span class="line" id="L159">    <span class="tok-kw">defer</span> recv_sock.close();</span>
<span class="line" id="L160"></span>
<span class="line" id="L161">    <span class="tok-comment">// Receive Datagrams and React to them (if applicable)</span>
</span>
<span class="line" id="L162">    <span class="tok-kw">var</span> dg_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L163">    <span class="tok-kw">const</span> infinite_dgs: <span class="tok-type">bool</span> = ia_config.recv_dgs_max == <span class="tok-number">0</span>;</span>
<span class="line" id="L164">    <span class="tok-comment">// - Multi-Threaded</span>
</span>
<span class="line" id="L165">    <span class="tok-kw">if</span> (ia_config.multithreaded) {</span>
<span class="line" id="L166">        log.debug(<span class="tok-str">&quot;Running Multi-Threaded.&quot;</span>, .{});</span>
<span class="line" id="L167">        <span class="tok-kw">var</span> recv_buf = InteractBuffer.init(alloc);</span>
<span class="line" id="L168">        <span class="tok-kw">var</span> recv_thread = <span class="tok-kw">try</span> std.Thread.spawn(</span>
<span class="line" id="L169">            .{ .allocator = alloc },</span>
<span class="line" id="L170">            recv.recvDatagramThread,</span>
<span class="line" id="L171">            .{</span>
<span class="line" id="L172">                alloc,</span>
<span class="line" id="L173">                recv_sock,</span>
<span class="line" id="L174">                &amp;recv_buf,</span>
<span class="line" id="L175">                ia_config.recv_dgs_max,</span>
<span class="line" id="L176">            }</span>
<span class="line" id="L177">        );</span>
<span class="line" id="L178">        <span class="tok-kw">defer</span> recv_thread.join();</span>
<span class="line" id="L179"></span>
<span class="line" id="L180">        <span class="tok-comment">// Run the Start Function (if applicable)</span>
</span>
<span class="line" id="L181">        time.sleep(ia_config.start_fn_delay);</span>
<span class="line" id="L182">        <span class="tok-kw">if</span> (ia_fns.start_fn) |startFn| <span class="tok-kw">try</span> startFn(alloc, fn_ctx);</span>
<span class="line" id="L183"></span>
<span class="line" id="L184">        <span class="tok-kw">while</span> (</span>
<span class="line" id="L185">            <span class="tok-kw">if</span> (!infinite_dgs) dg_count &lt; ia_config.recv_dgs_max</span>
<span class="line" id="L186">            <span class="tok-kw">else</span> <span class="tok-null">true</span></span>
<span class="line" id="L187">        ) {</span>
<span class="line" id="L188">            <span class="tok-kw">if</span> (ia_fns.react_fn) |reactFn| {</span>
<span class="line" id="L189">                <span class="tok-kw">if</span> (recv_buf.pop()) |datagram| {</span>
<span class="line" id="L190">                    <span class="tok-comment">//log.debug(&quot;Datagram Buffer Len: {d}&quot;, .{ recv_buf.list.items.len });</span>
</span>
<span class="line" id="L191">                    <span class="tok-comment">//log.debug(&quot;Spawning Thread.&quot;, .{});</span>
</span>
<span class="line" id="L192">                    <span class="tok-kw">var</span> thread = <span class="tok-kw">try</span> std.Thread.spawn(</span>
<span class="line" id="L193">                        .{ .allocator = alloc },</span>
<span class="line" id="L194">                        reactFn.*,</span>
<span class="line" id="L195">                        .{ alloc, fn_ctx, datagram }</span>
<span class="line" id="L196">                    );</span>
<span class="line" id="L197">                    thread.detach();</span>
<span class="line" id="L198">                    dg_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L199">                }</span>
<span class="line" id="L200">            }</span>
<span class="line" id="L201">        }</span>
<span class="line" id="L202">    }</span>
<span class="line" id="L203">    <span class="tok-comment">// - Single Threaded</span>
</span>
<span class="line" id="L204">    <span class="tok-kw">else</span> {</span>
<span class="line" id="L205">        <span class="tok-comment">// Run the Start Function (if applicable)</span>
</span>
<span class="line" id="L206">        <span class="tok-kw">if</span> (ia_fns.start_fn) |startFn| <span class="tok-kw">try</span> startFn(alloc, fn_ctx);</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">        log.debug(<span class="tok-str">&quot;Running Single-Threaded.&quot;</span>, .{});</span>
<span class="line" id="L209">        <span class="tok-kw">while</span> (</span>
<span class="line" id="L210">            <span class="tok-kw">if</span> (!infinite_dgs) dg_count &lt; ia_config.recv_dgs_max</span>
<span class="line" id="L211">            <span class="tok-kw">else</span> <span class="tok-null">true</span></span>
<span class="line" id="L212">        ) : (dg_count += <span class="tok-number">1</span>) {</span>
<span class="line" id="L213">            <span class="tok-kw">const</span> datagram = recv.recvDatagram(alloc, recv_sock) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L214">                <span class="tok-kw">error</span>.UnexpectedlySmallBuffer, </span>
<span class="line" id="L215">                <span class="tok-kw">error</span>.UnimplementedType =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L216">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L217">            };</span>
<span class="line" id="L218">            <span class="tok-kw">if</span> (ia_fns.react_fn) |reactFn| <span class="tok-kw">try</span> reactFn(alloc, fn_ctx, datagram);</span>
<span class="line" id="L219">        }</span>
<span class="line" id="L220">    }</span>
<span class="line" id="L221">    <span class="tok-comment">// Run the End Function (if applicable)</span>
</span>
<span class="line" id="L222">    <span class="tok-kw">if</span> (ia_fns.end_fn) |endFn| <span class="tok-kw">try</span> endFn(alloc, fn_ctx);</span>
<span class="line" id="L223">}</span>
<span class="line" id="L224"></span>
<span class="line" id="L225"><span class="tok-comment">// Interaction DSL (WIP) ====================================================================================</span>
</span>
<span class="line" id="L226"></span>
<span class="line" id="L227"><span class="tok-comment">///// Keywords for Interaction Expressions.</span>
</span>
<span class="line" id="L228"><span class="tok-comment">//pub const InteractExprKeywords = struct{</span>
</span>
<span class="line" id="L229"><span class="tok-comment">//    /// Top Level</span>
</span>
<span class="line" id="L230"><span class="tok-comment">//    pub const TopLevel = enum{</span>
</span>
<span class="line" id="L231"><span class="tok-comment">//        IF,</span>
</span>
<span class="line" id="L232"><span class="tok-comment">//        DO,</span>
</span>
<span class="line" id="L233"><span class="tok-comment">//        NEXT,</span>
</span>
<span class="line" id="L234"><span class="tok-comment">//    };</span>
</span>
<span class="line" id="L235"><span class="tok-comment">//    /// Boolean</span>
</span>
<span class="line" id="L236"><span class="tok-comment">//    pub const Boolean = enum{</span>
</span>
<span class="line" id="L237"><span class="tok-comment">//        AND,</span>
</span>
<span class="line" id="L238"><span class="tok-comment">//        OR,</span>
</span>
<span class="line" id="L239"><span class="tok-comment">//        NOT,</span>
</span>
<span class="line" id="L240"><span class="tok-comment">//    };</span>
</span>
<span class="line" id="L241"><span class="tok-comment">//    /// Condition</span>
</span>
<span class="line" id="L242"><span class="tok-comment">//    pub const Condition = enum{</span>
</span>
<span class="line" id="L243"><span class="tok-comment">//        EQUALS,</span>
</span>
<span class="line" id="L244"><span class="tok-comment">//        GREATER,</span>
</span>
<span class="line" id="L245"><span class="tok-comment">//        LESS,</span>
</span>
<span class="line" id="L246"><span class="tok-comment">//    };</span>
</span>
<span class="line" id="L247"><span class="tok-comment">//    /// Setter</span>
</span>
<span class="line" id="L248"><span class="tok-comment">//    pub const Setter = enum{</span>
</span>
<span class="line" id="L249"><span class="tok-comment">//        INC,</span>
</span>
<span class="line" id="L250"><span class="tok-comment">//        DEC,</span>
</span>
<span class="line" id="L251"><span class="tok-comment">//        SET,</span>
</span>
<span class="line" id="L252"><span class="tok-comment">//    };</span>
</span>
<span class="line" id="L253"><span class="tok-comment">//};</span>
</span>
<span class="line" id="L254"><span class="tok-comment">//</span>
</span>
<span class="line" id="L255"><span class="tok-comment">///// Parse Interaction Expressions (`expr`) to manipulate the Outbound Datagram (`out_dg`) based on the Inbound Datagram (`in_dg`).</span>
</span>
<span class="line" id="L256"><span class="tok-comment">//pub fn parseInteractExpr(in_dg: Datagrams.Full, out_dg: *Datagrams.Full, expr: []const []const u8) !void {</span>
</span>
<span class="line" id="L257"><span class="tok-comment">//    const Keywords = InteractExprKeywords;</span>
</span>
<span class="line" id="L258"><span class="tok-comment">//    var idx: u16 = 0;</span>
</span>
<span class="line" id="L259"><span class="tok-comment">//    while (idx &lt; expr.len) {</span>
</span>
<span class="line" id="L260"><span class="tok-comment">//        const line = expr[idx];</span>
</span>
<span class="line" id="L261"><span class="tok-comment">//        if (line.len == 0 or line[0] == '#') continue;</span>
</span>
<span class="line" id="L262"><span class="tok-comment">//        switch (meta.stringToEnum(Keywords.TopLevel, line) orelse {</span>
</span>
<span class="line" id="L263"><span class="tok-comment">//            log.err(&quot;The value '{s}' cannot be used at the Top Level. Only comments ('# ...') or 'IF', 'DO', and 'NEXT' may be used&quot;, .{ line });</span>
</span>
<span class="line" id="L264"><span class="tok-comment">//            return error.UnexpectedTopLevelValue;</span>
</span>
<span class="line" id="L265"><span class="tok-comment">//        }) {</span>
</span>
<span class="line" id="L266"><span class="tok-comment">//            .IF =&gt; {</span>
</span>
<span class="line" id="L267"><span class="tok-comment">//                const do_idx = (utils.indexOfEql([]const u8, expr[idx..], &quot;DO&quot;) orelse return error.NoMatchingThen) + idx;</span>
</span>
<span class="line" id="L268"><span class="tok-comment">//                const if_expr = expr[idx..do_idx];</span>
</span>
<span class="line" id="L269"><span class="tok-comment">//                if (!try parseIfExpr(in_dg, if_expr)) {</span>
</span>
<span class="line" id="L270"><span class="tok-comment">//                    idx = (utils.indexOfEql([]const u8, expr[idx..], &quot;NEXT&quot;) orelse return) + idx;</span>
</span>
<span class="line" id="L271"><span class="tok-comment">//                    continue;</span>
</span>
<span class="line" id="L272"><span class="tok-comment">//                }</span>
</span>
<span class="line" id="L273"><span class="tok-comment">//</span>
</span>
<span class="line" id="L274"><span class="tok-comment">//                idx = do_idx;</span>
</span>
<span class="line" id="L275"><span class="tok-comment">//                continue;</span>
</span>
<span class="line" id="L276"><span class="tok-comment">//            },</span>
</span>
<span class="line" id="L277"><span class="tok-comment">//            .DO =&gt; {</span>
</span>
<span class="line" id="L278"><span class="tok-comment">//                const next_idx = (utils.indexOfEql([]const u8, expr[idx..], &quot;NEXT&quot;) orelse expr[idx..].len) + idx;</span>
</span>
<span class="line" id="L279"><span class="tok-comment">//                const do_expr = expr[idx..next_idx];</span>
</span>
<span class="line" id="L280"><span class="tok-comment">//                try parseDoBlock(out_dg, do_expr);</span>
</span>
<span class="line" id="L281"><span class="tok-comment">//                idx = next_idx;</span>
</span>
<span class="line" id="L282"><span class="tok-comment">//            },</span>
</span>
<span class="line" id="L283"><span class="tok-comment">//            .NEXT =&gt; {},</span>
</span>
<span class="line" id="L284"><span class="tok-comment">//        }</span>
</span>
<span class="line" id="L285"><span class="tok-comment">//        idx += 1;</span>
</span>
<span class="line" id="L286"><span class="tok-comment">//    }</span>
</span>
<span class="line" id="L287"><span class="tok-comment">//}</span>
</span>
<span class="line" id="L288"><span class="tok-comment">//</span>
</span>
<span class="line" id="L289"><span class="tok-comment">///// Parse an &quot;IF&quot; Expression Block.</span>
</span>
<span class="line" id="L290"><span class="tok-comment">//fn parseIfBlock(in_dg: Datagrams.Full, block: []const []const u8) !bool {</span>
</span>
<span class="line" id="L291"><span class="tok-comment">//    _ = in_dg;</span>
</span>
<span class="line" id="L292"><span class="tok-comment">//    _ = block;</span>
</span>
<span class="line" id="L293"><span class="tok-comment">//</span>
</span>
<span class="line" id="L294"><span class="tok-comment">//    return false;</span>
</span>
<span class="line" id="L295"><span class="tok-comment">//}</span>
</span>
<span class="line" id="L296"><span class="tok-comment">//</span>
</span>
<span class="line" id="L297"><span class="tok-comment">///// Parse an &quot;DO&quot; Expression Block.</span>
</span>
<span class="line" id="L298"><span class="tok-comment">//fn parseDoBlock(out_dg: *Datagrams.Full, block: []const []const u8) !void {</span>
</span>
<span class="line" id="L299"><span class="tok-comment">//    _ = out_dg;</span>
</span>
<span class="line" id="L300"><span class="tok-comment">//    _ = block;</span>
</span>
<span class="line" id="L301"><span class="tok-comment">//}</span>
</span>
<span class="line" id="L302"><span class="tok-comment">//</span>
</span>
<span class="line" id="L303"><span class="tok-comment">///// Parse an &quot;IF&quot; Expression for a Datagram Field.</span>
</span>
<span class="line" id="L304"><span class="tok-comment">//fn parseIfExpr(field: anytype, sub_field_names: []const []const u8, expr: []const u8) !bool {</span>
</span>
<span class="line" id="L305"><span class="tok-comment">//    const FieldT = @TypeOf(field);</span>
</span>
<span class="line" id="L306"><span class="tok-comment">//</span>
</span>
<span class="line" id="L307"><span class="tok-comment">//    if (sub_field_names.len == 1) {</span>
</span>
<span class="line" id="L308"><span class="tok-comment">//        const sub_field = @field(FieldT, sub_field_names[0]);</span>
</span>
<span class="line" id="L309"><span class="tok-comment">//        const SubFieldT = @TypeOf(sub_field);</span>
</span>
<span class="line" id="L310"><span class="tok-comment">//        const cond_kw: InteractExprKeywords.Condition, </span>
</span>
<span class="line" id="L311"><span class="tok-comment">//        const cond_val: SubFieldT =</span>
</span>
<span class="line" id="L312"><span class="tok-comment">//            condition: {</span>
</span>
<span class="line" id="L313"><span class="tok-comment">//                var tokens = mem.split(u8, expr, ' ');</span>
</span>
<span class="line" id="L314"><span class="tok-comment">//                const val_str = tokens.next();</span>
</span>
<span class="line" id="L315"><span class="tok-comment">//                break :condition .{</span>
</span>
<span class="line" id="L316"><span class="tok-comment">//                    meta.stringToEnum(InteractExprKeywords.Condition, tokens.first()) orelse return error.UnknownConditionKeyword,</span>
</span>
<span class="line" id="L317"><span class="tok-comment">//                    switch (@typeInfo(SubFieldT)) {</span>
</span>
<span class="line" id="L318"><span class="tok-comment">//                        .Struct, .Union =&gt; try SubFieldT.fromStr(val_str),</span>
</span>
<span class="line" id="L319"><span class="tok-comment">//                        .Int =&gt; try fmt.parseInt(SubFieldT, val_str, 0),</span>
</span>
<span class="line" id="L320"><span class="tok-comment">//                        .Bool =&gt; ascii.eqlIgnoreCase(val_str, &quot;true&quot;),</span>
</span>
<span class="line" id="L321"><span class="tok-comment">//                        .Pointer =&gt; |ptr| slice: {</span>
</span>
<span class="line" id="L322"><span class="tok-comment">//                            if (ptr.child != u8) return error.PointerMustBeStringSlice;</span>
</span>
<span class="line" id="L323"><span class="tok-comment">//                            break :slice val_str;</span>
</span>
<span class="line" id="L324"><span class="tok-comment">//                        },</span>
</span>
<span class="line" id="L325"><span class="tok-comment">//                        inline else =&gt; error.UnsupportedType,</span>
</span>
<span class="line" id="L326"><span class="tok-comment">//                    }</span>
</span>
<span class="line" id="L327"><span class="tok-comment">//                };</span>
</span>
<span class="line" id="L328"><span class="tok-comment">//            };</span>
</span>
<span class="line" id="L329"><span class="tok-comment">//        _ = cond_val;</span>
</span>
<span class="line" id="L330"><span class="tok-comment">//        switch (cond_kw) {</span>
</span>
<span class="line" id="L331"><span class="tok-comment">//            .EQUALS =&gt; {},</span>
</span>
<span class="line" id="L332"><span class="tok-comment">//            else =&gt; {},</span>
</span>
<span class="line" id="L333"><span class="tok-comment">//        }</span>
</span>
<span class="line" id="L334"><span class="tok-comment">//        switch (@typeInfo(SubFieldT)) {</span>
</span>
<span class="line" id="L335"><span class="tok-comment">//            else =&gt; {},</span>
</span>
<span class="line" id="L336"><span class="tok-comment">//        }</span>
</span>
<span class="line" id="L337"><span class="tok-comment">//    }</span>
</span>
<span class="line" id="L338"><span class="tok-comment">//</span>
</span>
<span class="line" id="L339"><span class="tok-comment">//    switch (@typeInfo(FieldT)) {</span>
</span>
<span class="line" id="L340"><span class="tok-comment">//        .Struct, .Union =&gt; |type_info| {</span>
</span>
<span class="line" id="L341"><span class="tok-comment">//            inline for (type_info.fields) |sub_f| {</span>
</span>
<span class="line" id="L342"><span class="tok-comment">//                if (!mem.eql(u8, sub_field_names[0], sub_f)) continue;</span>
</span>
<span class="line" id="L343"><span class="tok-comment">//                return parseIfExpr(@field(FieldT, sub_f.name), sub_field_names[1..], expr);</span>
</span>
<span class="line" id="L344"><span class="tok-comment">//            }</span>
</span>
<span class="line" id="L345"><span class="tok-comment">//            else return error.UnknownField;</span>
</span>
<span class="line" id="L346"><span class="tok-comment">//        },</span>
</span>
<span class="line" id="L347"><span class="tok-comment">//        inline else =&gt; return error.ReachedDeepestField,</span>
</span>
<span class="line" id="L348"><span class="tok-comment">//    }</span>
</span>
<span class="line" id="L349"><span class="tok-comment">//}</span>
</span>
<span class="line" id="L350"><span class="tok-comment">//</span>
</span>
<span class="line" id="L351"><span class="tok-comment">//fn setDGField(dg: Datagrams.Full, expr: []const []const u8) !void {</span>
</span>
<span class="line" id="L352"><span class="tok-comment">//    _ = dg;</span>
</span>
<span class="line" id="L353"><span class="tok-comment">//    _ = expr;</span>
</span>
<span class="line" id="L354"><span class="tok-comment">//}</span>
</span>
<span class="line" id="L355"></span>
</code></pre></body>
</html>