<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Datagrams.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Datagram Union Templates</span></span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-comment">// Standard</span>
</span>
<span class="line" id="L4"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> log = std.log;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> meta = std.meta;</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-kw">const</span> strToEnum = meta.stringToEnum;</span>
<span class="line" id="L12"></span>
<span class="line" id="L13"><span class="tok-comment">// Zing</span>
</span>
<span class="line" id="L14"><span class="tok-kw">const</span> lib = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zinglib.zig&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">const</span> BFG = lib.BitFieldGroup;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> Frames = lib.Frames;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> Packets = lib.Packets;</span>
<span class="line" id="L18"></span>
<span class="line" id="L19"></span>
<span class="line" id="L20"><span class="tok-comment">/// Layer 2 Headers</span></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer2Header = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L22">    eth: Frames.EthFrame.Header,</span>
<span class="line" id="L23">    wifi: Frames.WifiFrame.Header,</span>
<span class="line" id="L24"></span>
<span class="line" id="L25">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L26">};</span>
<span class="line" id="L27"><span class="tok-comment">/// Layer 2 Options</span></span>
<span class="line" id="L28"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer2Option = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L29">    eth: Frames.EthFrame.Option,</span>
<span class="line" id="L30"></span>
<span class="line" id="L31">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L32">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> BFG.ImplBitFieldGroup(<span class="tok-builtin">@This</span>(), .{ </span>
<span class="line" id="L33">        .kind = BFG.Kind.OPTION, </span>
<span class="line" id="L34">        .layer = <span class="tok-number">2</span>,</span>
<span class="line" id="L35">    });</span>
<span class="line" id="L36">};</span>
<span class="line" id="L37"><span class="tok-comment">/// Layer 2 Footers</span></span>
<span class="line" id="L38"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer2Footer = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L39">    eth: Frames.EthFrame.Footer,</span>
<span class="line" id="L40">    wifi: Frames.WifiFrame.Footer,</span>
<span class="line" id="L41"></span>
<span class="line" id="L42">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L43">};</span>
<span class="line" id="L44"></span>
<span class="line" id="L45"><span class="tok-comment">/// Layer 3 Headers</span></span>
<span class="line" id="L46"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer3Header = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L47">    ip: Packets.IPPacket.Header,</span>
<span class="line" id="L48">    arp: Packets.ARPPacket.Header,</span>
<span class="line" id="L49"></span>
<span class="line" id="L50">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L51">};</span>
<span class="line" id="L52"><span class="tok-comment">/// Layer 3a Headers</span></span>
<span class="line" id="L53"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer3A_Header = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L54">    ip: Packets.IPPacket.SegmentPseudoHeader,</span>
<span class="line" id="L55"></span>
<span class="line" id="L56">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L57">};</span>
<span class="line" id="L58"><span class="tok-comment">/// Layer 3 Options</span></span>
<span class="line" id="L59"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer3Option = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L60">    ip: Packets.IPPacket.Option,</span>
<span class="line" id="L61"></span>
<span class="line" id="L62">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L63">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> BFG.ImplBitFieldGroup(<span class="tok-builtin">@This</span>(), .{ </span>
<span class="line" id="L64">        .kind = BFG.Kind.OPTION, </span>
<span class="line" id="L65">        .layer = <span class="tok-number">3</span>,</span>
<span class="line" id="L66">    });</span>
<span class="line" id="L67">};</span>
<span class="line" id="L68"></span>
<span class="line" id="L69"><span class="tok-comment">/// Layer 4 Headers</span></span>
<span class="line" id="L70"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer4Header = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L71">    udp: Packets.UDPPacket.Header,</span>
<span class="line" id="L72">    tcp: Packets.TCPPacket.Header,</span>
<span class="line" id="L73">    icmp: Packets.ICMPPacket.Header,</span>
<span class="line" id="L74"></span>
<span class="line" id="L75">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L76">};</span>
<span class="line" id="L77"><span class="tok-comment">/// Layer 4 Options</span></span>
<span class="line" id="L78"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Layer4Option = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L79">    tcp: Packets.TCPPacket.Option,</span>
<span class="line" id="L80"></span>
<span class="line" id="L81">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> ImplCommonToAll(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L82">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> BFG.ImplBitFieldGroup(<span class="tok-builtin">@This</span>(), .{ </span>
<span class="line" id="L83">        .kind = BFG.Kind.OPTION, </span>
<span class="line" id="L84">        .layer = <span class="tok-number">4</span>,</span>
<span class="line" id="L85">    });</span>
<span class="line" id="L86">};</span>
<span class="line" id="L87"></span>
<span class="line" id="L88"><span class="tok-comment">/// Common-to-All Datagram Functions</span></span>
<span class="line" id="L89"><span class="tok-kw">fn</span> <span class="tok-fn">ImplCommonToAll</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L90">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span>{</span>
<span class="line" id="L91">        <span class="tok-comment">/// Call the asBytes method of the inner BitFieldGroup.</span></span>
<span class="line" id="L92">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asBytes</span>(self: *<span class="tok-kw">const</span> T, alloc: mem.Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L93">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*)) {</span>
<span class="line" id="L94">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L95">                    <span class="tok-kw">var</span> bfg = <span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L96">                    <span class="tok-kw">return</span> </span>
<span class="line" id="L97">                        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(bfg), <span class="tok-str">&quot;asBytes&quot;</span>)) <span class="tok-kw">try</span> bfg.asBytes(alloc)</span>
<span class="line" id="L98">                        <span class="tok-kw">else</span> <span class="tok-kw">error</span>.NoAsBytesMethod;</span>
<span class="line" id="L99">                },</span>
<span class="line" id="L100">            };</span>
<span class="line" id="L101">        }</span>
<span class="line" id="L102"></span>
<span class="line" id="L103">        <span class="tok-comment">/// Call the asNetBytesBFG method of the inner BitFieldGroup.</span></span>
<span class="line" id="L104">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asNetBytes</span>(self: *<span class="tok-kw">const</span> T, alloc: mem.Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L105">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*)) {</span>
<span class="line" id="L106">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L107">                    <span class="tok-kw">var</span> bfg = <span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L108">                    <span class="tok-kw">return</span> </span>
<span class="line" id="L109">                        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(bfg), <span class="tok-str">&quot;asNetBytesBFG&quot;</span>)) <span class="tok-kw">try</span> bfg.asNetBytesBFG(alloc)</span>
<span class="line" id="L110">                        <span class="tok-kw">else</span> <span class="tok-kw">error</span>.NoAsBytesMethod;</span>
<span class="line" id="L111">                },</span>
<span class="line" id="L112">            };</span>
<span class="line" id="L113">        }</span>
<span class="line" id="L114"></span>
<span class="line" id="L115"></span>
<span class="line" id="L116">        <span class="tok-comment">/// Call the specific calc method of the inner BitFieldGroup.</span></span>
<span class="line" id="L117">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calc</span>(self: *T, alloc: mem.Allocator, pre: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, opts_len: <span class="tok-type">u16</span>, payload: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L118">            <span class="tok-kw">switch</span> (meta.activeTag(self.*)) {</span>
<span class="line" id="L119">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L120">                    <span class="tok-kw">var</span> bfg = <span class="tok-builtin">@constCast</span>(&amp;<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(tag)));</span>
<span class="line" id="L121">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(bfg.*), <span class="tok-str">&quot;calcLengthAndChecksum&quot;</span>)) <span class="tok-kw">try</span> bfg.calcLengthAndChecksum(alloc, pre, opts_len, payload)</span>
<span class="line" id="L122">                    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(bfg.*), <span class="tok-str">&quot;calcCRC&quot;</span>)) <span class="tok-kw">try</span> bfg.calcCRC(alloc, payload)</span>
<span class="line" id="L123">                    <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoCalcMethod;</span>
<span class="line" id="L124">                },</span>
<span class="line" id="L125">            }</span>
<span class="line" id="L126">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L127">        }</span>
<span class="line" id="L128"></span>
<span class="line" id="L129">        <span class="tok-comment">/// Switch the endianness of the inner BitFieldGroup to Little Endian.</span></span>
<span class="line" id="L130">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLE</span>(self: *T) !<span class="tok-type">void</span> {</span>
<span class="line" id="L131">            <span class="tok-kw">switch</span> (meta.activeTag(self.*)) {</span>
<span class="line" id="L132">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L133">                    <span class="tok-kw">var</span> bfg = &amp;<span class="tok-builtin">@field</span>(self, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L134">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(bfg.*), <span class="tok-str">&quot;toLSB&quot;</span>)) <span class="tok-kw">try</span> bfg.toLSB();</span>
<span class="line" id="L135">                }</span>
<span class="line" id="L136">            }</span>
<span class="line" id="L137">        }</span>
<span class="line" id="L138">    };</span>
<span class="line" id="L139">}</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"></span>
<span class="line" id="L142"><span class="tok-comment">/// Full Layer 2 - 4 Datagram</span></span>
<span class="line" id="L143"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Full = <span class="tok-kw">struct</span>{</span>
<span class="line" id="L144">    l2_header: Layer2Header = .{ .eth = .{} },</span>
<span class="line" id="L145">    l2_options: ?[]Layer2Option = <span class="tok-null">null</span>,</span>
<span class="line" id="L146">    l3_header: ?Layer3Header = .{ .ip = .{} },</span>
<span class="line" id="L147">    l3_options: ?[]Layer3Option = <span class="tok-null">null</span>,</span>
<span class="line" id="L148">    l4_header: ?Layer4Header = .{ .udp = .{} },</span>
<span class="line" id="L149">    l4_options: ?[]Layer4Option = <span class="tok-null">null</span>,</span>
<span class="line" id="L150">    payload: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;Hello World!&quot;</span>,</span>
<span class="line" id="L151">    l2_footer: ?Layer2Footer = .{ .eth = .{} },</span>
<span class="line" id="L152"></span>
<span class="line" id="L153">    <span class="tok-comment">/// Initialize a Full Datagram based on the given Headers, Payload, and Footer types.</span></span>
<span class="line" id="L154">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(layer: <span class="tok-type">u3</span>, headers: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, payload: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, footer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L155">        <span class="tok-kw">const</span> l_diff = <span class="tok-number">2</span> - <span class="tok-builtin">@as</span>(<span class="tok-type">i4</span>, <span class="tok-builtin">@intCast</span>(layer)); <span class="tok-comment">// Layer Difference. Aligns input headers based on given layer.</span>
</span>
<span class="line" id="L156">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L157">            .l2_header = <span class="tok-kw">if</span> (layer &gt; <span class="tok-number">2</span> <span class="tok-kw">and</span> headers.len &lt; <span class="tok-number">3</span>) .{ .eth = .{} } <span class="tok-kw">else</span> l2Hdr: {</span>
<span class="line" id="L158">                <span class="tok-kw">const</span> l2_hdr_type = strToEnum(meta.Tag(Layer2Header), headers[<span class="tok-number">0</span>]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidHeader;</span>
<span class="line" id="L159">                <span class="tok-kw">switch</span>(l2_hdr_type) { </span>
<span class="line" id="L160">                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |l2_hdr_tag| <span class="tok-kw">break</span> :l2Hdr <span class="tok-builtin">@unionInit</span>(Layer2Header, <span class="tok-builtin">@tagName</span>(l2_hdr_tag), .{}),</span>
<span class="line" id="L161">                }</span>
<span class="line" id="L162">            },</span>
<span class="line" id="L163">            .l3_header = <span class="tok-kw">if</span> (layer &gt; <span class="tok-number">3</span> <span class="tok-kw">and</span> headers.len &lt; <span class="tok-number">2</span>) .{ .ip = .{} } <span class="tok-kw">else</span> l3Hdr: {</span>
<span class="line" id="L164">                <span class="tok-kw">const</span> l3_hdr_type = strToEnum(meta.Tag(Layer3Header), headers[<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(l_diff + <span class="tok-number">1</span>))]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidHeader;</span>
<span class="line" id="L165">                <span class="tok-kw">switch</span>(l3_hdr_type) {</span>
<span class="line" id="L166">                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |l3_hdr_tag| <span class="tok-kw">break</span> :l3Hdr <span class="tok-builtin">@unionInit</span>(Layer3Header, <span class="tok-builtin">@tagName</span>(l3_hdr_tag), .{}),</span>
<span class="line" id="L167">                }</span>
<span class="line" id="L168">            },</span>
<span class="line" id="L169">            .l4_header = l4Hdr: {</span>
<span class="line" id="L170">                <span class="tok-kw">const</span> l4_hdr_type = strToEnum(meta.Tag(Layer4Header), headers[<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(l_diff + <span class="tok-number">2</span>))]) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :l4Hdr <span class="tok-null">null</span>;</span>
<span class="line" id="L171">                <span class="tok-kw">switch</span> (l4_hdr_type) {</span>
<span class="line" id="L172">                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |l4_hdr_tag| <span class="tok-kw">break</span> :l4Hdr <span class="tok-builtin">@unionInit</span>(Layer4Header, <span class="tok-builtin">@tagName</span>(l4_hdr_tag), .{}),</span>
<span class="line" id="L173">                }</span>
<span class="line" id="L174">            },</span>
<span class="line" id="L175">            .payload = payload,</span>
<span class="line" id="L176">            .l2_footer = <span class="tok-kw">if</span> (layer &gt; <span class="tok-number">2</span>) .{ .eth = .{} } <span class="tok-kw">else</span> l2Hdr: {</span>
<span class="line" id="L177">                <span class="tok-kw">const</span> l2_ftr_type = strToEnum(meta.Tag(Layer2Footer), footer) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFooter;</span>
<span class="line" id="L178">                <span class="tok-kw">switch</span>(l2_ftr_type) { </span>
<span class="line" id="L179">                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |l2_ftr_tag| <span class="tok-kw">break</span> :l2Hdr <span class="tok-builtin">@unionInit</span>(Layer2Footer, <span class="tok-builtin">@tagName</span>(l2_ftr_tag), .{}),</span>
<span class="line" id="L180">                }</span>
<span class="line" id="L181">            },</span>
<span class="line" id="L182">        };</span>
<span class="line" id="L183">    }</span>
<span class="line" id="L184"></span>
<span class="line" id="L185">    <span class="tok-comment">/// Perform various calculations (Length, Checksum, etc...) for each relevant field within this Datagram</span></span>
<span class="line" id="L186">    <span class="tok-comment">/// User must free.</span></span>
<span class="line" id="L187">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcFromPayload</span>(self: *<span class="tok-builtin">@This</span>(), alloc: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L188">        <span class="tok-comment">// Data Payload</span>
</span>
<span class="line" id="L189">        <span class="tok-kw">if</span> (self.payload.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> self.payload[self.payload.len - <span class="tok-number">1</span>] != <span class="tok-str">'\n'</span>) self.payload = <span class="tok-kw">try</span> mem.concat(alloc, <span class="tok-type">u8</span>, &amp;.{ self.payload, <span class="tok-str">&quot;\n&quot;</span> });</span>
<span class="line" id="L190">        <span class="tok-kw">const</span> payload = <span class="tok-builtin">@constCast</span>(self.payload);</span>
<span class="line" id="L191"></span>
<span class="line" id="L192">        <span class="tok-comment">// Layer 4 </span>
</span>
<span class="line" id="L193">        <span class="tok-kw">if</span> (self.l4_header) |_| {</span>
<span class="line" id="L194">            <span class="tok-kw">const</span> l3a_hdr: ?Layer3A_Header = l3aHdr: {</span>
<span class="line" id="L195">                <span class="tok-kw">const</span> l3_hdr = <span class="tok-kw">if</span> (self.l3_header) |hdr| hdr <span class="tok-kw">else</span> <span class="tok-kw">break</span> :l3aHdr <span class="tok-null">null</span>;</span>
<span class="line" id="L196">                <span class="tok-kw">break</span> :l3aHdr <span class="tok-kw">switch</span> (meta.activeTag(l3_hdr)) {</span>
<span class="line" id="L197">                    .ip =&gt; .{ .ip = .{</span>
<span class="line" id="L198">                        .src_ip_addr = l3_hdr.ip.src_ip_addr,</span>
<span class="line" id="L199">                        .dst_ip_addr = l3_hdr.ip.dst_ip_addr,</span>
<span class="line" id="L200">                        .protocol = <span class="tok-builtin">@intCast</span>(l3_hdr.ip.protocol),</span>
<span class="line" id="L201">                    } },</span>
<span class="line" id="L202">                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L203">                };</span>
<span class="line" id="L204">            };</span>
<span class="line" id="L205">            <span class="tok-kw">const</span> l3a_hdr_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =</span>
<span class="line" id="L206">                <span class="tok-kw">if</span> (l3a_hdr) |p_hdr| <span class="tok-kw">try</span> p_hdr.asNetBytes(alloc)</span>
<span class="line" id="L207">                <span class="tok-kw">else</span> &amp;.{};</span>
<span class="line" id="L208">            <span class="tok-kw">const</span> opts_len: <span class="tok-type">u16</span>,</span>
<span class="line" id="L209">            <span class="tok-kw">const</span> l4_payload = </span>
<span class="line" id="L210">                <span class="tok-kw">if</span> (self.l4_options) |opts| l4Payload: {</span>
<span class="line" id="L211">                    <span class="tok-kw">if</span> (opts.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :l4Payload .{ <span class="tok-builtin">@intCast</span>(opts.len), payload };</span>
<span class="line" id="L212">                    <span class="tok-kw">var</span> pl_list = std.ArrayList(<span class="tok-type">u8</span>).init(alloc);</span>
<span class="line" id="L213">                    <span class="tok-kw">for</span> (opts) |*opt| <span class="tok-kw">try</span> pl_list.appendSlice(<span class="tok-kw">try</span> <span class="tok-builtin">@constCast</span>(opt).asNetBytes(alloc));</span>
<span class="line" id="L214">                    <span class="tok-kw">try</span> pl_list.appendSlice(payload);</span>
<span class="line" id="L215">                    <span class="tok-kw">break</span> :l4Payload .{ <span class="tok-builtin">@intCast</span>(opts.len), <span class="tok-kw">try</span> pl_list.toOwnedSlice() };</span>
<span class="line" id="L216">                }</span>
<span class="line" id="L217">                <span class="tok-kw">else</span> .{ <span class="tok-number">0</span>, payload };</span>
<span class="line" id="L218">            <span class="tok-kw">try</span> self.l4_header.?.calc(alloc, l3a_hdr_bytes, opts_len, l4_payload);</span>
<span class="line" id="L219">        }</span>
<span class="line" id="L220">        </span>
<span class="line" id="L221">        <span class="tok-comment">// Layer 3</span>
</span>
<span class="line" id="L222">        <span class="tok-kw">const</span> l3_payload: []<span class="tok-type">u8</span> = <span class="tok-kw">if</span> (self.l3_header) |_| l3Payload: {</span>
<span class="line" id="L223">            <span class="tok-kw">const</span> opts_len: <span class="tok-type">u16</span>,</span>
<span class="line" id="L224">            <span class="tok-kw">const</span> l3_opts =</span>
<span class="line" id="L225">                <span class="tok-kw">if</span> (self.l3_options) |opts| .{</span>
<span class="line" id="L226">                    <span class="tok-builtin">@intCast</span>(opts.len),</span>
<span class="line" id="L227">                    l3Opts: { </span>
<span class="line" id="L228">                        <span class="tok-kw">var</span> opts_list = std.ArrayList(<span class="tok-type">u8</span>).init(alloc);</span>
<span class="line" id="L229">                        <span class="tok-kw">for</span> (opts) |*opt| <span class="tok-kw">try</span> opts_list.appendSlice(<span class="tok-kw">try</span> <span class="tok-builtin">@constCast</span>(opt).asNetBytes(alloc));</span>
<span class="line" id="L230">                        <span class="tok-kw">break</span> :l3Opts <span class="tok-kw">try</span> opts_list.toOwnedSlice();</span>
<span class="line" id="L231">                    },</span>
<span class="line" id="L232">                }</span>
<span class="line" id="L233">                <span class="tok-kw">else</span> .{ <span class="tok-number">0</span>, &amp;.{} };</span>
<span class="line" id="L234"></span>
<span class="line" id="L235">            <span class="tok-kw">const</span> l3_pl = </span>
<span class="line" id="L236">                <span class="tok-kw">if</span> (self.l4_header) |_| <span class="tok-kw">try</span> mem.concat(alloc, <span class="tok-type">u8</span>, &amp;.{ </span>
<span class="line" id="L237">                    l3_opts,</span>
<span class="line" id="L238">                    <span class="tok-kw">try</span> self.l4_header.?.asNetBytes(alloc), </span>
<span class="line" id="L239">                    payload,</span>
<span class="line" id="L240">                }) </span>
<span class="line" id="L241">                <span class="tok-kw">else</span> payload;</span>
<span class="line" id="L242">            <span class="tok-kw">try</span> self.l3_header.?.calc(alloc, &amp;.{}, opts_len, l3_pl);</span>
<span class="line" id="L243">            <span class="tok-kw">break</span> :l3Payload l3_pl;</span>
<span class="line" id="L244">        }</span>
<span class="line" id="L245">        <span class="tok-kw">else</span> &amp;.{};</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">        <span class="tok-comment">// Layer 2</span>
</span>
<span class="line" id="L248">        <span class="tok-kw">if</span> (self.l2_footer) |_| {</span>
<span class="line" id="L249">            <span class="tok-kw">const</span> l2_payload = </span>
<span class="line" id="L250">                <span class="tok-kw">if</span> (self.l3_header) |_| <span class="tok-kw">try</span> mem.concat(alloc, <span class="tok-type">u8</span>, &amp;.{ </span>
<span class="line" id="L251">                    <span class="tok-kw">try</span> self.l2_header.asNetBytes(alloc), </span>
<span class="line" id="L252">                    <span class="tok-kw">try</span> self.l3_header.?.asNetBytes(alloc), </span>
<span class="line" id="L253">                    l3_payload,</span>
<span class="line" id="L254">                })</span>
<span class="line" id="L255">                <span class="tok-kw">else</span> <span class="tok-kw">try</span> mem.concat(alloc, <span class="tok-type">u8</span>, &amp;.{</span>
<span class="line" id="L256">                    <span class="tok-kw">try</span> self.l2_header.asNetBytes(alloc),</span>
<span class="line" id="L257">                    payload,</span>
<span class="line" id="L258">                });</span>
<span class="line" id="L259">                    </span>
<span class="line" id="L260">            <span class="tok-kw">try</span> self.l2_footer.?.calc(alloc, &amp;.{}, <span class="tok-number">0</span>, l2_payload);</span>
<span class="line" id="L261">        }</span>
<span class="line" id="L262">    }</span>
<span class="line" id="L263"></span>
<span class="line" id="L264">    <span class="tok-comment">/// Returns this Datagram as a Byte Array in Network Byte Order / Big Endian. Network Byte Order words are 32-bits.</span></span>
<span class="line" id="L265">    <span class="tok-comment">/// User must free. TODO - Determine if freeing the returned slice also frees out_buf. (Copied from BitFieldGroup.zig)</span></span>
<span class="line" id="L266">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asNetBytes</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), alloc: mem.Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L267">        <span class="tok-kw">var</span> bytes_list = std.ArrayList(<span class="tok-type">u8</span>).init(alloc);</span>
<span class="line" id="L268">        <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> self.l2_header.asNetBytes(alloc)); </span>
<span class="line" id="L269">        <span class="tok-kw">if</span> (self.l3_header) |l3_hdr| <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> l3_hdr.asNetBytes(alloc));</span>
<span class="line" id="L270">        <span class="tok-kw">if</span> (self.l3_options) |l3_opts|</span>
<span class="line" id="L271">            <span class="tok-kw">for</span> (l3_opts) |opt| <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> opt.asNetBytes(alloc));</span>
<span class="line" id="L272">        <span class="tok-kw">if</span> (self.l4_header) |l4_hdr| <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> l4_hdr.asNetBytes(alloc));</span>
<span class="line" id="L273">        <span class="tok-kw">if</span> (self.l4_options) |l4_opts|</span>
<span class="line" id="L274">            <span class="tok-kw">for</span> (l4_opts) |opt| <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> opt.asNetBytes(alloc));</span>
<span class="line" id="L275">        <span class="tok-kw">try</span> bytes_list.appendSlice(self.payload); </span>
<span class="line" id="L276">        <span class="tok-kw">if</span> (self.l2_footer) |l2_ftr| <span class="tok-kw">try</span> bytes_list.appendSlice(<span class="tok-kw">try</span> l2_ftr.asNetBytes(alloc));</span>
<span class="line" id="L277"></span>
<span class="line" id="L278">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> bytes_list.toOwnedSlice();</span>
<span class="line" id="L279">    }</span>
<span class="line" id="L280"></span>
<span class="line" id="L281">    <span class="tok-comment">/// Creates a Full Datagram from the provided Frame Buffer (`frame_buf`) bytes.</span></span>
<span class="line" id="L282">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(alloc: mem.Allocator, frame_buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, l2_type: meta.Tag(Layer2Header)) !<span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L283">        <span class="tok-comment">//var datagram = try alloc.create(@This());</span>
</span>
<span class="line" id="L284">        <span class="tok-kw">var</span> datagram: <span class="tok-builtin">@This</span>() = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L285"></span>
<span class="line" id="L286">        <span class="tok-comment">// Layer 2</span>
</span>
<span class="line" id="L287">        <span class="tok-kw">const</span> EthHeader = lib.Frames.EthFrame.Header;</span>
<span class="line" id="L288">        <span class="tok-comment">// TODO: Convert each Layer and sub-Type to their own functions since slice indexes must be compile time known.</span>
</span>
<span class="line" id="L289">        <span class="tok-kw">const</span> l3_buf, <span class="tok-kw">const</span> l3_type, <span class="tok-kw">const</span> l2_footer_len: <span class="tok-type">usize</span> = l2Hdr: {</span>
<span class="line" id="L290">            <span class="tok-kw">switch</span> (l2_type) {</span>
<span class="line" id="L291">                .eth =&gt; {</span>
<span class="line" id="L292">                    <span class="tok-kw">var</span> eth_frame = Frames.EthFrame.from(frame_buf);</span>
<span class="line" id="L293">                    <span class="tok-kw">const</span> eth_type_raw = mem.bigToNative(<span class="tok-type">u16</span>, eth_frame.header.ether_type);</span>
<span class="line" id="L294">                    <span class="tok-kw">try</span> eth_frame.header.toLSB();</span>
<span class="line" id="L295">                    datagram.l2_header = .{ .eth = eth_frame.header };</span>
<span class="line" id="L296">                    datagram.l2_options = <span class="tok-null">null</span>; <span class="tok-comment">//TODO</span>
</span>
<span class="line" id="L297">                    <span class="tok-kw">break</span> :l2Hdr .{ </span>
<span class="line" id="L298">                        frame_buf[eth_frame.len..],</span>
<span class="line" id="L299">                        eth_type_raw, </span>
<span class="line" id="L300">                        <span class="tok-builtin">@bitSizeOf</span>(lib.Frames.EthFrame.Footer) / <span class="tok-number">8</span>,</span>
<span class="line" id="L301">                    };</span>
<span class="line" id="L302">                },</span>
<span class="line" id="L303">                <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L304">                    log.err(<span class="tok-str">&quot;Unparseable Layer 2 Type '{s}'.&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(tag) });</span>
<span class="line" id="L305">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedType;</span>
<span class="line" id="L306">                },</span>
<span class="line" id="L307">            }</span>
<span class="line" id="L308">        };</span>
<span class="line" id="L309"></span>
<span class="line" id="L310">        <span class="tok-comment">// Layer 3</span>
</span>
<span class="line" id="L311">        <span class="tok-kw">if</span> (!EthHeader.EtherTypes.inEnum(l3_type)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedType;</span>
<span class="line" id="L312">        <span class="tok-kw">const</span> payload_buf = <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(EthHeader.EtherTypes.Enum(), <span class="tok-builtin">@enumFromInt</span>(l3_type))) {</span>
<span class="line" id="L313">            .IPv4 =&gt; ipv4Payload: {</span>
<span class="line" id="L314">                <span class="tok-kw">const</span> ip_packet = <span class="tok-kw">try</span> Packets.IPPacket.from(alloc, l3_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L315">                <span class="tok-kw">const</span> l4_buf = l3_buf[ip_packet.len..];</span>
<span class="line" id="L316"></span>
<span class="line" id="L317">                <span class="tok-kw">const</span> IPProtos = Packets.IPPacket.Header.Protocols;</span>
<span class="line" id="L318">                datagram.l3_header = .{ .ip = ip_packet.header };</span>
<span class="line" id="L319">                datagram.l3_options = <span class="tok-kw">if</span> (ip_packet.options) |opts| <span class="tok-builtin">@ptrCast</span>(opts) <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">                <span class="tok-comment">// Layer 4</span>
</span>
<span class="line" id="L322">                <span class="tok-kw">if</span> (!IPProtos.inEnum(ip_packet.header.protocol)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedType;</span>
<span class="line" id="L323">                <span class="tok-kw">break</span> :ipv4Payload <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(IPProtos.Enum(), <span class="tok-builtin">@enumFromInt</span>(ip_packet.header.protocol))) {</span>
<span class="line" id="L324">                    .UDP =&gt; payload: {</span>
<span class="line" id="L325">                        <span class="tok-kw">const</span> UDPHeader = lib.Packets.UDPPacket.Header;</span>
<span class="line" id="L326">                        <span class="tok-kw">const</span> udp_hdr_end = (<span class="tok-builtin">@bitSizeOf</span>(UDPHeader) / <span class="tok-number">8</span>);</span>
<span class="line" id="L327">                        <span class="tok-kw">var</span> udp_hdr = mem.bytesToValue(UDPHeader, l4_buf[<span class="tok-number">0</span>..udp_hdr_end]);</span>
<span class="line" id="L328">                        <span class="tok-kw">try</span> udp_hdr.toLSB();</span>
<span class="line" id="L329">                        datagram.l4_header = .{ .udp = udp_hdr };</span>
<span class="line" id="L330">                        datagram.l4_options = <span class="tok-null">null</span>;</span>
<span class="line" id="L331">                        <span class="tok-kw">break</span> :payload l4_buf[udp_hdr_end..];</span>
<span class="line" id="L332">                    },</span>
<span class="line" id="L333">                    .TCP =&gt; payload: {</span>
<span class="line" id="L334">                        <span class="tok-kw">const</span> tcp_packet = <span class="tok-kw">try</span> Packets.TCPPacket.from(alloc, l4_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L335">                        datagram.l4_header = .{ .tcp = tcp_packet.header };</span>
<span class="line" id="L336">                        datagram.l4_options = <span class="tok-kw">if</span> (tcp_packet.options) |opts| <span class="tok-builtin">@ptrCast</span>(opts) <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L337">                        log.debug(<span class="tok-str">&quot;TCP LEN: {d}B | {d}W&quot;</span>, .{ tcp_packet.len, tcp_packet.header.data_offset });</span>
<span class="line" id="L338">                        <span class="tok-kw">break</span> :payload l4_buf[<span class="tok-builtin">@min</span>(l4_buf.len, tcp_packet.len)..];</span>
<span class="line" id="L339">                    },</span>
<span class="line" id="L340">                    .ICMP =&gt; payload: {</span>
<span class="line" id="L341">                        <span class="tok-kw">const</span> ICMPHeader = lib.Packets.ICMPPacket.Header;</span>
<span class="line" id="L342">                        <span class="tok-kw">const</span> icmp_hdr_end = (<span class="tok-builtin">@bitSizeOf</span>(ICMPHeader) / <span class="tok-number">8</span>);</span>
<span class="line" id="L343">                        <span class="tok-kw">var</span> size_buf: [<span class="tok-builtin">@sizeOf</span>(ICMPHeader)]<span class="tok-type">u8</span> = .{ <span class="tok-number">0</span> } ** <span class="tok-builtin">@sizeOf</span>(ICMPHeader);</span>
<span class="line" id="L344">                        <span class="tok-kw">for</span> (size_buf[<span class="tok-number">0</span>..icmp_hdr_end], l4_buf[<span class="tok-number">0</span>..icmp_hdr_end]) |*s, b| s.* = b;</span>
<span class="line" id="L345">                        <span class="tok-kw">var</span> icmp_hdr = mem.bytesToValue(ICMPHeader, size_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L346">                        <span class="tok-kw">try</span> icmp_hdr.toLSB();</span>
<span class="line" id="L347">                        datagram.l4_header = .{ .icmp = icmp_hdr };</span>
<span class="line" id="L348">                        datagram.l4_options = <span class="tok-null">null</span>;</span>
<span class="line" id="L349">                        <span class="tok-kw">break</span> :payload l4_buf[icmp_hdr_end..];</span>
<span class="line" id="L350">                    },</span>
<span class="line" id="L351">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L352">                        <span class="tok-comment">//log.warn(&quot;Not a parseable IP Protocol '{s}'. Finished parsing.&quot;, .{ ip_proto });</span>
</span>
<span class="line" id="L353">                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedType;</span>
<span class="line" id="L354">                    },</span>
<span class="line" id="L355">                };</span>
<span class="line" id="L356"></span>
<span class="line" id="L357">            },</span>
<span class="line" id="L358">            .ARP =&gt; arpPayload: {</span>
<span class="line" id="L359">                <span class="tok-kw">const</span> ARPHeader = lib.Packets.ARPPacket.Header;</span>
<span class="line" id="L360">                <span class="tok-kw">const</span> arp_hdr_end = (<span class="tok-builtin">@bitSizeOf</span>(ARPHeader) / <span class="tok-number">8</span>);</span>
<span class="line" id="L361">                <span class="tok-kw">var</span> size_buf: [<span class="tok-builtin">@sizeOf</span>(ARPHeader)]<span class="tok-type">u8</span> = .{ <span class="tok-number">0</span> } ** <span class="tok-builtin">@sizeOf</span>(ARPHeader);</span>
<span class="line" id="L362">                <span class="tok-kw">for</span> (size_buf[<span class="tok-number">0</span>..arp_hdr_end], l3_buf[<span class="tok-number">0</span>..arp_hdr_end]) |*s, b| s.* = b;</span>
<span class="line" id="L363">                <span class="tok-comment">//var arp_hdr: ARPHeader = @bitCast(l3_buf[0..arp_hdr_end].*);</span>
</span>
<span class="line" id="L364">                <span class="tok-kw">var</span> arp_hdr = mem.bytesToValue(ARPHeader, size_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L365">                <span class="tok-kw">try</span> arp_hdr.toLSB();</span>
<span class="line" id="L366"></span>
<span class="line" id="L367">                datagram.l3_header = .{ .arp = arp_hdr };</span>
<span class="line" id="L368">                datagram.l3_options = <span class="tok-null">null</span>;</span>
<span class="line" id="L369">                datagram.l4_header = <span class="tok-null">null</span>;</span>
<span class="line" id="L370">                datagram.l4_options = <span class="tok-null">null</span>;</span>
<span class="line" id="L371">                datagram.payload = <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L372">                datagram.l2_footer = <span class="tok-null">null</span>;</span>
<span class="line" id="L373">                <span class="tok-kw">break</span> :arpPayload l3_buf[arp_hdr_end..];</span>
<span class="line" id="L374">            },</span>
<span class="line" id="L375">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L376">                <span class="tok-comment">//log.warn(&quot;Not a parseable Ethernet Protocol '{d}'. Finished parsing.&quot;, .{ l3_type });</span>
</span>
<span class="line" id="L377">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedType;</span>
<span class="line" id="L378">            },</span>
<span class="line" id="L379">        };</span>
<span class="line" id="L380"></span>
<span class="line" id="L381">        <span class="tok-comment">// Payload</span>
</span>
<span class="line" id="L382">        <span class="tok-kw">const</span> footer_diff: <span class="tok-type">i128</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(payload_buf.len)) - <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(l2_footer_len));</span>
<span class="line" id="L383">        <span class="tok-kw">if</span> (footer_diff &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L384">            <span class="tok-kw">if</span> (datagram.l3_header) |l3_hdr| pl: {</span>
<span class="line" id="L385">                <span class="tok-kw">switch</span> (l3_hdr) {</span>
<span class="line" id="L386">                    .arp =&gt; {</span>
<span class="line" id="L387">                        datagram.payload = <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L388">                        datagram.l2_footer = <span class="tok-null">null</span>;</span>
<span class="line" id="L389">                        <span class="tok-kw">return</span> datagram;</span>
<span class="line" id="L390">                    },</span>
<span class="line" id="L391">                    <span class="tok-comment">//.ip =&gt; {</span>
</span>
<span class="line" id="L392">                    <span class="tok-comment">//    const payload_end = payload_buf.len - l2_footer_len;</span>
</span>
<span class="line" id="L393">                    <span class="tok-comment">//    datagram.payload = if (payload_end &gt; 0) payload_buf[0..payload_end] else &quot;&quot;;</span>
</span>
<span class="line" id="L394">                    <span class="tok-comment">//    datagram.l2_footer = null;</span>
</span>
<span class="line" id="L395">                    <span class="tok-comment">//    return datagram;</span>
</span>
<span class="line" id="L396">                    <span class="tok-comment">//},</span>
</span>
<span class="line" id="L397">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :pl,</span>
<span class="line" id="L398">                }</span>
<span class="line" id="L399">            }</span>
<span class="line" id="L400">            log.err(<span class="tok-str">&quot;End of Datagram Buffer is {d}B too small for the Footer.&quot;</span>, .{ -<span class="tok-number">1</span> * footer_diff }); </span>
<span class="line" id="L401">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedlySmallBuffer;</span>
<span class="line" id="L402">        }</span>
<span class="line" id="L403">        <span class="tok-kw">const</span> payload_end = payload_buf.len - l2_footer_len;</span>
<span class="line" id="L404">        datagram.payload = <span class="tok-kw">if</span> (payload_end &gt; <span class="tok-number">0</span>) payload_buf[<span class="tok-number">0</span>..payload_end] <span class="tok-kw">else</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">        <span class="tok-comment">// Footer</span>
</span>
<span class="line" id="L407">        <span class="tok-kw">const</span> footer_buf = payload_buf[payload_end..(payload_end + <span class="tok-number">4</span>)];</span>
<span class="line" id="L408">        <span class="tok-kw">switch</span>(l2_type) {</span>
<span class="line" id="L409">            .eth =&gt; {</span>
<span class="line" id="L410">                <span class="tok-kw">const</span> EthFooter = lib.Frames.EthFrame.Footer;</span>
<span class="line" id="L411">                <span class="tok-kw">var</span> size_buf: [<span class="tok-builtin">@sizeOf</span>(EthFooter)]<span class="tok-type">u8</span> = .{ <span class="tok-number">0</span> } ** <span class="tok-builtin">@sizeOf</span>(EthFooter);</span>
<span class="line" id="L412">                <span class="tok-kw">for</span> (size_buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>], footer_buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>]) |*s, b| s.* = b;</span>
<span class="line" id="L413">                <span class="tok-kw">var</span> eth_footer = mem.bytesToValue(EthFooter, size_buf[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L414">                <span class="tok-kw">try</span> eth_footer.toLSB();</span>
<span class="line" id="L415"></span>
<span class="line" id="L416">                datagram.l2_footer = .{ .eth = eth_footer };</span>
<span class="line" id="L417">            },</span>
<span class="line" id="L418">            .wifi =&gt; {},</span>
<span class="line" id="L419">        }</span>
<span class="line" id="L420"></span>
<span class="line" id="L421">        <span class="tok-kw">return</span> datagram;</span>
<span class="line" id="L422">    }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">    <span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> BFG.ImplBitFieldGroup(<span class="tok-builtin">@This</span>(), .{ .kind = .FRAME });</span>
<span class="line" id="L425">};</span>
<span class="line" id="L426"></span>
<span class="line" id="L427"></span>
</code></pre></body>
</html>